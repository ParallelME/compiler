# ParallelME Compiler for the impatient

## ParallelME Overview

ParallelME, a Parallel Mobile Engine, was designed to explore heterogeneity in Android devices, automatically coordinating the usage of computing resources while maintaining the programming effort similar to what sequential programmers expect. In our tests, compared to a sequential Java code, the framework was able to increase application performance by more than 30 times with an equivalent programming complexity in number of lines of code and a reduction of 98% of energy consumption. It was conceived as a complete infrastructure for parallel programming for mobile architectures, being composed of three main components: (1) a programming abstraction proposed in a user-library, (2) a source-to-source compiler and (3) a run-time environment.

* The user-library holds the programming abstraction proposed by ParallelME, being the high-level API that is directly handled by the user code. It was inspired by the Scala collections library and is designed to provide an easy-to-use and generic programming model for parallel applications in Java for Android. This programming abstraction offers a collection-driven approach for code development of specific types of data sets, also introducing special functions to iterate, reduce, perform data-transformation and create sub-sets in these collections. These operations are executed, after translated by ParallelME compiler, in high-performance parallel run-times at NDK level. Once debugging at NDK level is not an easy task, a fully functional sequential implementation in Java is also provided for each collection. It means that user applications can be debugged at SDK level in Java using the regular Android development infrastructure.
* The source-to-source compiler provides a mechanism for translating user code to a low-level parallel implementation in the specified high-performance run-times. It takes as an input Java code written with the user-library and translates it to a new version integrated with both RenderScript and ParallelME run-time. This translation is performed during development time, leaving the choice of which target run-time to execute to the user application execution time. The output code generated by ParallelME will evaluate during user application execution if the hardware supports OpenCL and perform execution of high-performance code in ParallelME run-time. In case there is no support for OpenCL, the code generated by ParallelME compiler will transparently switch to RenderScript, which is supported by a greater range of Android devices.
* The run-time environment was developed using OpenCL and is responsible for setting up the application to allow several parallel tasks to be specified and queued for execution in different devices. Compared to Google's RenderScript, ParallelME run-time was able to increase application performance by more than 2 times, while reducing energy consumption by an average 5%.

## How to use this compiler

Since we still don't have a plugin that integrates ParallelME to Android Studio ([help wanted](https://github.com/ParallelME/compiler/issues/25)), you have to do some manual work in order to use our framework, so follow the steps bellow to use our compiler to translate code written with [ParallelME User-library](https://github.com/ParallelME/userlibrary):

* Install [Maven](https://maven.apache.org/) and make sure it is configured on the PATH variable;
* Download ParallelME compiler source code to your machine;
* Navigate to **parallelme-compiler* folder and execute the command **mvn clean package**;
* If everything goes fine, a **parallelme-compiler-VERSION.jar** file will be created in the **target** folder.
* Execute **java -jar parallelme-compiler-VERSION.jar -f UserClass.java -o ./output** to compile **UserClass.java** file and save translated files in **output** folder;
* If the translation was succesfull, three folders namely **java**, **jni** and **rs** were created in **output** folder;
* Copy these three folders to **app/src/main** folder in your application structure, replacing the your original class (in the example, **UserClass.java**);
* ParallelME compiler create a new constructor for your **UserClass.java** in order to run RenderScript. Use this new constructor in your application like the following example in [this file](https://github.com/parallelme/samples/blob/master/ArrayTest/app/src/main/java/org/parallelme/samples/arraytest/MainActivity.java) where we create the compiler translated ArrayTest class:
```
mArrayTest = new ArrayTest(RenderScript.create(this));
```
* Finally, prior to compiling the translated code in Android Studio, you must compile those jni files (these are ParallelME Run-time stuff). So, open a command line prompt, go to the **app/src/main** folder again and execute the command **ndk-build**.

After all the above steps, your application written with ParallelME User-library should be able to be deployed in your device. If you have any problems, please let us know.

**PS: We have plans for an Android Studio plugin to avoid all these boring steps, but we need help to create it. If you want to help us improve ParallelME, join us!**

## Detailed information

If you need detailed information about ParallelME compiler, please refer to [ParallelME Reference Manual](https://parallelme.github.io/docs/ParallelME_Reference_Manual.pdf) and check the compiler section.
